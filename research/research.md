Strategy:
- Customer row stored in numpy memmap, simulation happens in memory with object interactions, snapshots taken to PyArrow
- Basically: Customer data is stored and manipulated within a table, object interactions happen within memory.
Constants:
Home station dictionary {"T1": "Central"}
Data model and interactions:

- Customer:
    - Attributes: id (u64), origin_station_id (u32), dest_station_id (u32), current_station_id (u32), on_train_id (u32, 0=not on train), state (u8: 0=waiting,1=onboard,2=arrived,3=transferring), tap_on_ts (f8), tap_off_ts (f8), spawn_ts (f8), path_id (u32, references PathTable), total_wait_time (f8), total_travel_time (f8), movement_speed (f4)
    - Stored in: numpy memmap (columnar, high-throughput)
    - No methods; manipulated via vectorized ops by Simulation Loop and Station.
    - Generated by: CustomerGenerator
    - Updated by: Simulation Loop (boarding, alighting, state transitions)

- Train:
    - Attributes: id, line_id, timetable [(arrival_time, station_id), ...], current_station_id, next_station_id, dwell_remaining, max_capacity, current_capacity, onboard_passengers [list of customer indices], direction (1 or -1), status (in_service/idle/out_of_service)
    - Methods:
        - step(dt): advance along timetable, update position, detect arrivals
        - board(passenger_indices): add to onboard if capacity permits
        - alight(): return list of customer indices whose dest == current_station
        - reverse_direction(): flip direction at terminal, reset timetable pointer
    - Generated by: TrainGenerator
    - Updated by: Simulation Loop

- Station:
    - Attributes: station_id, name, line_codes [list], avg_change_time, theoretical_capacity, maximum_capacity, waiting_passengers [list of customer indices], platforms (optional: dict platform_id -> train_ids)
    - Methods:
        - enqueue_passenger(customer_idx): add to waiting queue
        - dequeue_for_boarding(train): select passengers to board, filter by path/line
        - update_capacity(): track current occupancy
        - transfer_passenger(customer_idx, next_line): move to transfer queue
    - Interacts with: Train (boarding/alighting), CustomerGenerator (new arrivals), Map (transfer options)

- Line:
    - Attributes: line_id, line_code (e.g., "T1"), station_list [ordered station_ids], time_between_stations [list of travel times], schedule, fleet_size, direction (1 or -1 or 0 for bidirectional), train_generator (TrainGenerator instance)
    - Methods:
        - get_next_station(current_station_id, direction) -> station_id
        - get_travel_time(from_id, to_id) -> float
        - update_fleet(new_size): adjust active fleet
        - notify_disruption(event): propagate to TrainGenerator
    - Owns: TrainGenerator
    - Interacts with: Map (routing), Simulation Loop (train updates)

- Map:
    - Attributes: lines [list of Line objects], stations [dict station_id -> Station], adjacency (graph or matrix), path_table (PathTable instance), station_lookup (name -> Station)
    - Methods:
        - find_path(origin_id, dest_id) -> path_id
        - get_transfer_options(station_id) -> list of line_codes
        - assign_path_to_customer(customer_idx): write path_id to memmap
    - Interacts with: CustomerGenerator (initial routing), Simulation Loop (transfer decisions)

- PathTable (helper):
    - Attributes: paths [dict path_id -> [(line_code, from_id, to_id), ...]]
    - Methods:
        - plan(origin, dest) -> path_id (or create new if not cached)
        - expand(path_id) -> list of segments
    - Used by: Map, Customer (via path_id reference)

- Simulation Loop:
    - Attributes: current_tick, active_trains [list], event_queue [sorted list of events], snapshot_interval, memmap_ref (passengers array)
    - Methods:
        - step(): advance tick, update trains, process events, apply boarding/alighting, emit deltas
        - process_events(): handle scheduled events (arrivals, disruptions)
        - snapshot(): convert changed columns to PyArrow, write Parquet
        - collect_metrics(): boarding_rate, avg_wait, etc.
    - Interacts with: all objects; orchestrates simulation

Helper Objects:
- CustomerGenerator:
    - Attributes: arrival_rate_profile, rng, customer_counter, free_indices, station_id
    - Methods:
        - generate_customers(t) -> list of new customer indices
        - allocate_index() -> int
        - assign_path(customer_idx, map): call map.find_path and write to memmap
    - One instance per station or per OD pair
    - Interacts with: Map (routing), Simulation Loop (spawn timing)

- TrainGenerator:
    - Attributes: line_id, fleet_size, schedule_policy, active_trains (set), idle_pool (list), next_spawn_times
    - Methods:
        - tick(t) -> list of spawn events
        - allocate_train() -> train_id or None
        - release_train(train_id): return to idle pool
        - handle_direction_change(train_id): manage reversal at terminal
    - Owned by: Line
    - Interacts with: Simulation Loop (train creation), Line (schedule info)

TODO answers:
- Fleet size: TrainGenerator maintains active_trains set; spawning checks len(active_trains) < fleet_size. Trains return to idle_pool when service completes.
- Direction changes: Train.reverse_direction() flips direction attribute and resets timetable pointer at terminals. TrainGenerator can schedule bidirectional routes or reassign idle trains.

